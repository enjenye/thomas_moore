-- File: proc.vhd
-- Generated by MyHDL 0.9.0
-- Date: Sun Mar 11 16:57:52 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_090.all;

entity proc is
    port (
        LED: out unsigned(11 downto 0);
        SW: in unsigned(11 downto 0);
        CLK100MHZ: in std_logic
    );
end entity proc;
-- shallow stack processor

architecture MyHDL of proc is





signal A: signed (11 downto 0);
signal md: signed (11 downto 0);
signal C: signed (11 downto 0);
signal B: signed (11 downto 0);
signal I: signed (11 downto 0);
signal skip: unsigned(2 downto 0);
signal rd: std_logic;
signal ext: std_logic;
signal inst: unsigned(5 downto 0);
signal wr: std_logic;
signal dinp: signed (11 downto 0);
signal ma: signed (11 downto 0);
type t_array_mem is array(0 to 4096-1) of unsigned(11 downto 0);
signal mem: t_array_mem;

begin





PROC_MEM_WR: process (CLK100MHZ) is
begin
    if rising_edge(CLK100MHZ) then
        if bool(wr) then
            if (ma = (-1)) then
                LED <= unsigned(md);
            else
                mem(to_integer(ma)) <= unsigned(md);
            end if;
        end if;
    end if;
end process PROC_MEM_WR;


PROC_MEM_RD: process (A, mem, SW) is
begin
    if (A = (-1)) then
        dinp <= signed(SW);
    else
        dinp <= signed(mem(to_integer(A)));
    end if;
end process PROC_MEM_RD;


PROC_ROM_RD: process (I) is
begin
    case to_integer(I) is
        when 0 => inst <= "010101";
        when 1 => inst <= "010010";
        when 2 => inst <= "000101";
        when 3 => inst <= "010011";
        when 4 => inst <= "010110";
        when 5 => inst <= "001001";
        when 6 => inst <= "010000";
        when 7 => inst <= "000101";
        when 8 => inst <= "010000";
        when 9 => inst <= "001011";
        when 10 => inst <= "010000";
        when 11 => inst <= "001010";
        when 12 => inst <= "000101";
        when 13 => inst <= "011111";
        when 14 => inst <= "001011";
        when 15 => inst <= "010001";
        when 16 => inst <= "001001";
        when 17 => inst <= "010000";
        when 18 => inst <= "001011";
        when 19 => inst <= "010000";
        when 20 => inst <= "000101";
        when 21 => inst <= "010001";
        when 22 => inst <= "001001";
        when 23 => inst <= "000101";
        when 24 => inst <= "010100";
        when 25 => inst <= "001110";
        when 26 => inst <= "011111";
        when 27 => inst <= "011111";
        when 28 => inst <= "011000";
        when 29 => inst <= "001101";
        when 30 => inst <= "000100";
        when 31 => inst <= "011111";
        when 32 => inst <= "011110";
        when 33 => inst <= "011000";
        when 34 => inst <= "001101";
        when 35 => inst <= "001111";
        when 36 => inst <= "000000";
        when 37 => inst <= "000000";
        when 38 => inst <= "000000";
        when 39 => inst <= "000000";
        when 40 => inst <= "000000";
        when 41 => inst <= "000000";
        when 42 => inst <= "000000";
        when 43 => inst <= "000000";
        when 44 => inst <= "000000";
        when 45 => inst <= "000000";
        when 46 => inst <= "000000";
        when 47 => inst <= "000000";
        when 48 => inst <= "000000";
        when 49 => inst <= "000000";
        when 50 => inst <= "000000";
        when 51 => inst <= "000000";
        when 52 => inst <= "000000";
        when 53 => inst <= "000000";
        when 54 => inst <= "000000";
        when 55 => inst <= "000000";
        when 56 => inst <= "000000";
        when 57 => inst <= "000000";
        when 58 => inst <= "000000";
        when 59 => inst <= "000000";
        when 60 => inst <= "000000";
        when 61 => inst <= "000000";
        when 62 => inst <= "000000";
        when others => inst <= "000000";
    end case;
end process PROC_ROM_RD;


PROC_LOGIC: process (CLK100MHZ) is
    variable oper: unsigned(3 downto 0);
    variable jmp: signed(11 downto 0);
    variable stck: unsigned(1 downto 0);
    variable cnst: unsigned(0 downto 0);
    variable halt: std_logic;
begin
    if rising_edge(CLK100MHZ) then
        ext <= '0';
        rd <= '0';
        wr <= '0';
        jmp := (I + 1);
        halt := '0';
        cnst := inst(5-1 downto 4);
        oper := inst(4-1 downto 0);
        if (skip > 0) then
            skip <= (skip - 1);
            I <= (I + 1);
        elsif bool(cnst) then
            ext <= '1';
            if bool(ext) then
                A <= (shift_left(A, 4) or signed(resize(oper, 12)));
            else
                A <= resize(signed(oper), 12);
                B <= A;
                C <= B;
                stck := to_unsigned(1, 2);
            end if;
        else
            if (oper = 0) then
                A <= (not A);
            else
                case oper is
                    when "0001" =>
                        A <= (-A);
                    when "0010" =>
                        A <= shift_left(A, 1);
                    when "0011" =>
                        A <= shift_right(A, 1);
                    when "0100" =>
                        A <= B;
                        B <= C;
                    when "0101" =>
                        B <= A;
                        C <= B;
                    when "0110" =>
                        A <= C;
                        B <= A;
                        C <= B;
                    when "0111" =>
                        A <= (A xor B);
                        B <= C;
                    when "1000" =>
                        A <= (A and B);
                        B <= C;
                    when "1001" =>
                        A <= (A + B);
                        B <= C;
                    when others =>
                        if (oper = 10) then
                            A <= signed(unsigned(dinp));
                            rd <= '1';
                        else
                            if (oper = 11) then
                                ma <= A;
                                md <= B;
                                wr <= '1';
                                A <= C;
                                B <= C;
                            else
                                case oper is
                                    when "1100" =>
                                        jmp := A;
                                        A <= (I + 1);
                                    when "1101" =>
                                        jmp := (I + A);
                                        A <= B;
                                        B <= C;
                                    when others =>
                                        if (oper = 14) then
                                            if (B = 0) then
                                                skip <= unsigned(A(3-1 downto 0));
                                            end if;
                                            A <= C;
                                            B <= C;
                                        elsif (oper = 15) then
                                            
                                        end if;
                                end case;
                            end if;
                        end if;
                end case;
            end if;
        end if;
        I <= jmp;
        
    end if;
end process PROC_LOGIC;

end architecture MyHDL;
