-- File: proc.vhd
-- Generated by MyHDL 0.9.0
-- Date: Sun Mar 11 14:34:38 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_090.all;

entity proc is
    port (
        LED: out unsigned(11 downto 0);
        SW: in unsigned(11 downto 0);
        CLK100MHZ: in std_logic
    );
end entity proc;
-- shallow stack processor

architecture MyHDL of proc is





signal A: signed (11 downto 0);
signal C: signed (11 downto 0);
signal B: signed (11 downto 0);
signal I: signed (11 downto 0);
signal skip: unsigned(2 downto 0);
signal rd: std_logic;
signal ext: std_logic;
signal inst: unsigned(4 downto 0);
signal wr: std_logic;
signal dinp: signed (11 downto 0);
type t_array_mem is array(0 to 4096-1) of unsigned(11 downto 0);
signal mem: t_array_mem;

begin





PROC_MEM_WR: process (CLK100MHZ) is
begin
    if rising_edge(CLK100MHZ) then
        if bool(wr) then
            if (A = (-1)) then
                LED <= unsigned(B);
            else
                mem(to_integer(A)) <= unsigned(B);
            end if;
        end if;
    end if;
end process PROC_MEM_WR;


PROC_MEM_RD: process (A, mem, SW) is
begin
    if (A = (-1)) then
        dinp <= signed(SW);
    else
        dinp <= signed(mem(to_integer(A)));
    end if;
end process PROC_MEM_RD;


PROC_ROM_RD: process (I) is
begin
    case to_integer(I) is
        when 0 => inst <= "10101";
        when 1 => inst <= "10010";
        when 2 => inst <= "00101";
        when 3 => inst <= "10011";
        when 4 => inst <= "10110";
        when 5 => inst <= "01001";
        when 6 => inst <= "10000";
        when 7 => inst <= "00101";
        when 8 => inst <= "11111";
        when 9 => inst <= "01011";
        when 10 => inst <= "10001";
        when 11 => inst <= "01001";
        when 12 => inst <= "00101";
        when 13 => inst <= "11111";
        when 14 => inst <= "10110";
        when 15 => inst <= "01001";
        when 16 => inst <= "10100";
        when 17 => inst <= "01110";
        when 18 => inst <= "11111";
        when 19 => inst <= "11111";
        when 20 => inst <= "10011";
        when 21 => inst <= "01101";
        when 22 => inst <= "01111";
        when 23 => inst <= "00000";
        when 24 => inst <= "00000";
        when 25 => inst <= "00000";
        when 26 => inst <= "00000";
        when 27 => inst <= "00000";
        when 28 => inst <= "00000";
        when 29 => inst <= "00000";
        when 30 => inst <= "00000";
        when others => inst <= "00000";
    end case;
end process PROC_ROM_RD;


PROC_LOGIC: process (CLK100MHZ) is
    variable oper: unsigned(3 downto 0);
    variable jmp: signed(11 downto 0);
    variable stck: unsigned(1 downto 0);
    variable cnst: unsigned(0 downto 0);
    variable halt: std_logic;
begin
    if rising_edge(CLK100MHZ) then
        ext <= '0';
        rd <= '0';
        wr <= '0';
        jmp := (I + 1);
        halt := '0';
        cnst := inst(5-1 downto 4);
        oper := inst(4-1 downto 0);
        if (skip > 0) then
            skip <= (skip - 1);
            I <= (I + 1);
        elsif bool(cnst) then
            ext <= '1';
            if bool(ext) then
                A <= (shift_left(A, 4) or signed(resize(oper, 12)));
            else
                A <= resize(signed(oper), 12);
                B <= A;
                C <= B;
                stck := to_unsigned(1, 2);
            end if;
        else
            if (oper = 0) then
                A <= (not A);
            else
                case oper is
                    when "0001" =>
                        A <= (-A);
                    when "0010" =>
                        A <= shift_left(A, 1);
                    when "0011" =>
                        A <= shift_right(A, 1);
                    when "0100" =>
                        A <= B;
                        B <= C;
                    when "0101" =>
                        B <= A;
                        C <= B;
                    when "0110" =>
                        A <= C;
                        B <= A;
                        C <= B;
                    when "0111" =>
                        A <= (A xor B);
                        B <= C;
                    when "1000" =>
                        A <= (A and B);
                        B <= C;
                    when "1001" =>
                        A <= (A + B);
                        B <= C;
                    when others =>
                        case oper is
                            when "1010" =>
                                A <= signed(unsigned(dinp));
                                rd <= '1';
                            when "1011" =>
                                A <= C;
                                B <= C;
                                wr <= '1';
                            when "1100" =>
                                jmp := A;
                                A <= (I + 1);
                            when "1101" =>
                                jmp := (I + A);
                                A <= B;
                                B <= C;
                            when others =>
                                if (oper = 14) then
                                    if (B = 0) then
                                        skip <= unsigned(A(3-1 downto 0));
                                    end if;
                                    A <= C;
                                    B <= C;
                                elsif (oper = 15) then
                                    
                                end if;
                        end case;
                end case;
            end if;
        end if;
        I <= jmp;
        
    end if;
end process PROC_LOGIC;

end architecture MyHDL;
